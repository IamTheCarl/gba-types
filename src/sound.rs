//! Audio related registers.
//!
//! Overview:
//! There are 6 sound channels.
//! The first 4 are mono sound generators and are referred to as the PSG
//! (Programable sound generator) Channel 1: Tone and Sweep
//! Channel 2: Tone
//! Channel 3: Wave based tone
//! Channel 4: Noise
//! Channel A and B: DMA sound sample playback.
//!
//! Channels 1 and 2 are the same in memory layout and function, except channel
//! 1 has an extra register for doing tone sweeps.
//!
//! Channel 3 can playback small wave segments consisting of 32 nibbles. This
//! can be used to create unique tones for music playback.
//!
//! Channel 4 is a white noise generator. It does so by generating a constant
//! tone and then adjusting the envelope pseudo randomly.
//!
//! Channels A and B: These are DMA sound channels, capable of playing back a
//! continuous stream of sample data. A and B can be set to output from the
//! left, right, or both speaker at once. This means they are the only audio
//! channels capable of stereo audio output.
//!
//! Note that the first 4 sound channels are mixed in with channels A and B as
//! if they were a 3rd DMA channel.

bitstruct_newtype! {
  /// Control register used for tone sweeps, generated by audio channel 1.
  ToneSweep(u8) {
    /// The frequency value is not incremented, but rather bit shifted.
    /// This is how much it should be shifted. This is an unsigned integer and does not set direction.
    /// See decreasing_sweep for that.
    [0-2: sweep_shift_count, set_sweep_shift_count],
    /// If set to false, the tone will increase. If set to true, the tone will decrease.
    [3: decreasing_sweep, set_decreasing_sweep],
    /// The amount of time between each step the shift takes, in units of 7.8ms.
    [4-6: sweep_time_chunk, set_sweep_time_chunk],
  }
}

const_enum! {
  /// Valid duty cycles for tone generation.
  ToneWavePatternDuty(u16) {
    /// Active duty cycle of 12.5%.
    _12_5(0 << 6),
    /// Active duty cycle of 25%.
    _25(1 << 6),
    /// Active duty cycle of 50%.
    _50(2 << 6),
    /// Active duty cycle of 75%.
    _75(3 << 6),
  }
}

bitstruct_newtype! {
  /// Set the duty cycle, length, and envelope of a tone generated by channel 1 or 2.
  ToneDutyLenEnvelope(u16) {
      /// The length the tone/sweep should be played for in units of (64-n)/256s.
      [0-5: sound_length, set_sound_length],
      /// Set the duty cycle of the tone.
      [6-7 => ToneWavePatternDuty: duty_cycle, set_duty_cycle],
      /// Envelope step time. Set to 0 to disable. Otherwise will increment/decrement the envelope by this value every n/64s.
      /// Use the increasing_envelope field to set if this value is incrementing or decrementing.
      [8-10: envelope_step_time, set_envelope_step_time],
      /// Set to true for an increasing envelope. Set to false for a decreasing envelope.
      [11: increasing_envelope, set_increasing_envelope],
      /// Set the initial volume of the tone.
      [12-15: initial_volume, set_initial_volume],
  }
}

bitstruct_newtype! {
  /// Control register used for tones generated by audio channel 1 and 2.
  ToneFrequencyControl(u16) {
    /// The frequency of the tone, being 131072/(2048-n)Hz.
    [0-10: frequency, set_frequency],
    /// Set to true to cause the tone to stop as soon as its time expires.
    /// Setting to false will cause the tone to restart as soon as it finishes, making for a continuous tone.
    [14: stop_at_end, set_stop_at_end],
    /// Set to true to start the tone.
    /// If set to false while the tone is playing, the tone will stop.
    [15: init, set_init],
  }
}

bitstruct_newtype! {
  /// RAM select register for channel 3.
  WaveRamSelect(u8) {
    /// Set to false to use a single bank, or true to use duel banking.
    /// Only one bank will be read from at a time. This is like double buffering for video, but an audio channel instead.
    [5: two_banks, set_two_banks],
    /// Set set to false to use bank 0 for playback.
    /// Set to true to use bank 1 for playback.
    [6: using_bank1, set_using_bank1],
    /// Set to true to start playback.
    /// Setting to false will interrupt and stop playback.
    [7: playing, set_playing],
  }
}

const_enum! {
  /// Playback volume of the wave, in percentages.
  WaveVolume(u8) {
    /// 0% of original playback volume.
    _0(0 << 5),
    /// 100% of original playback volume.
    _100(1 << 5),
    /// 50% of original playback volume.
    _50(2 << 5),
    /// 25% of original playback volume.
    _25(3 << 5),
    /// 75% of original playback volume.
    _75(0b100 << 5),
  }
}

bitstruct_newtype! {
  /// Set the volume of audio playback for channel 3.
  /// This represents the second half of the SOUND3CNT_H register.
  /// The first half of that register (the sample block length) can just be accessed
  /// as a single u8, so no special struct is provided.
  WaveVolumeSetting(u8) {
    /// Playback volume of sample block.
    [5-7 => WaveVolume: volume, set_volume],
  }
}

bitstruct_newtype! {
  /// Sets the frequency at which samples are played back at. Don't mistake this for directly
  /// controlling the actual tone to be generated. That's more dependent on the actual samples
  /// being played. This just controls the rate at which those samples will be played.
  WaveFrequencyControl(u16) {
    /// The rate at which samples will be played back.
    /// Can be set to values 0 to 2047. The resulting sample rate will be 2097152/(2048-n),
    /// n being the value you set here.
    [0-10: sample_rate, set_sample_rate],
    /// Set to true to cause playback to stop when the sample completes playback.
    /// If set to false, samples will be looped.
    [14: stop_at_end, set_stop_at_end],
    /// Set to true to start playback from the beginning of the sample.
    /// Clearing to false accomplishes nothing.
    [15: init, set_init],
  }
}

bitstruct_newtype! {
  /// Length and envelope settings of the noise generator.
  NoiseLengthEnvelope(u16) {
    /// The length of the sound in units of (64-n)/256s.
    [0-5: length, set_length],
    /// Envelope step time in units of n/64s.
    /// Set to zero for no envelope.
    [8-10: envelope_step_time, set_envelope_step_time],
    /// Set to true for an increasing envelope.
    /// Clear to false for a decreasing envelope.
    [11: increasing_envelope, set_increasing_envelope],
    /// The initial volume of the noise, 0 being 0% and 15 being 100%.
    [12-15: initial_volume, set_initial_volume],
  }
}

bitstruct_newtype! {
  /// The frequency at which the amplitude of the noise generator will be randomly changed.
  /// It is said that higher frequencies will sound "softer".
  ///
  /// The frequency is a bit complicated to control. You must use the following equation to
  /// control it.
  ///
  /// (524288 Hz / dividing_ratio) / (2 ^ ( shift_clock_frequency + 1 ))
  NoiseFrequencyControl(u16) {
    /// Dividing ration. See equation above.
    /// Do note that if you input a value of 0 here, dividing_ratio will behave as if it is set to 0.5.
    [0-2: dividing_ratio, set_dividing_ratio],
    /// Counter step width.
    [3: step_width_7bits, set_step_width_7bits],
    /// Shift clock frequency. See equation above.
    [4-7: shift_clock_frequency, set_shift_clock_frequency],
    /// Set to true to stop the sound when the full sound length has been played.
    /// If cleared to false, the sound will loop.
    [14: stop_at_end, set_stop_at_end],
    /// Set to true to start/restart playback.
    /// Setting to false will accomplish nothing.
    [15: init, set_init],
  }
}

bitstruct_newtype! {
  /// Sets the volume levels of the DMA audio output channels.
  /// The scale is 0 being 0% volume and 7 being 100% volume.
  GeneratedSoundLeftRightMainVolume(u8) {
    /// Set the right output volume.
    [0-2: right, set_right],
    /// Set the left output volume.
    [4-6: left, set_left],
  }
}

bitstruct_newtype! {
  /// Use to enable sound outputs.
  GeneratedSoundLeftRightEnabled(u8) {
    /// Set true to enable sound 1 on the right speaker.
    /// Set false to disable.
    [0: right_sound_1_enabled, set_right_sound_1_enabled],
    /// Set true to enable sound 2 on the right speaker.
    /// Set false to disable.
    [1: right_sound_2_enabled, set_right_sound_2_enabled],
    /// Set true to enable sound 3 on the right speaker.
    /// Set false to disable.
    [2: right_sound_3_enabled, set_right_sound_3_enabled],
    /// Set true to enable sound 4 on the right speaker.
    /// Set false to disable.
    [3: right_sound_4_enabled, set_right_sound_4_enabled],
    /// Set true to enable sound 1 on the left speaker.
    /// Set false to disable.
    [4: left_sound_1_enabled, set_left_sound_1_enabled],
    /// Set true to enable sound 2 on the left speaker.
    /// Set false to disable.
    [5: left_sound_2_enabled, set_left_sound_2_enabled],
    /// Set true to enable sound 3 on the left speaker.
    /// Set false to disable.
    [6: left_sound_3_enabled, set_left_sound_3_enabled],
    /// Set true to enable sound 4 on the left speaker.
    /// Set false to disable.
    [7: left_sound_4_enabled, set_left_sound_4_enabled],
  }
}

const_enum! {
  /// Playback volume of the first 4 sound generators.
  GeneratedSoundMixingVolume(u8) {
    /// 25% volume.
    _25(0),
    /// 50% volume.
    _50(1),
    /// 100% volume.
    _100(2),
  }
}

bitstruct_newtype! {
  /// Volume levels of individual DMA channels.
  DmaSoundMixVolumeControl(u8) {
    /// Sound channels 1-4 are mixed in with A and B at this volume.
    [0-1 => GeneratedSoundMixingVolume: generated_volume, set_generated_volume],
    /// Channel A volume, which 0 being 50% and 1 being 100%.
    [2: sound_a_full, set_sound_a_full],
    /// Channel B volume, which 0 being 50% and 1 being 100%.
    [3: sound_b_full, set_sound_b_full],
  }
}

bitstruct_newtype! {
  /// DMA sound control.
  DmaSoundControlBits(u8) {
    /// Set true to enable channel A output on right speaker.
    /// Clear to false to disable.
    [0: sound_a_right, set_sound_a_right],
    /// Set true to enable channel A output on left speaker.
    /// Clear to false to disable.
    [1: sound_a_left, set_sound_a_left],
    /// Use to select the timer for sound channel A. Setting to 0 will select timer0.
    /// Setting to 1 will select timer 1.
    [2: sound_a_timer1, set_sound_a_timer1],
    /// Set true to reset sound fifo A.
    /// Clearing to false will do nothing.
    [3: sound_a_fifo_reset, set_sound_a_fifo_reset],
    /// Set true to enable channel B output on right speaker.
    /// Clear to false to disable.
    [4: sound_b_right, set_sound_b_right],
    /// Set true to enable channel B output on left speaker.
    /// Clear to false to disable.
    [5: sound_b_left, set_sound_b_left],
    /// Use to select the timer for sound channel B. Setting to 0 will select timer0.
    /// Setting to 1 will select timer 1.
    [6: sound_b_timer1, set_sound_b_timer1],
    /// Set true to reset sound fifo B.
    /// Clearing to false will do nothing.
    [7: sound_b_fifo_reset, set_sound_b_fifo_reset],
  }
}

// Note(Lokathor): PSG = Programmable Sound Generator

bitstruct_newtype! {
  /// Indicates active audio channels.
  /// Permits disabling all audio output.
  GeneratedSoundActiveBits(u8) {
    /// Is true when sound channel 1 is active, and false otherwise.
    [0: sound_1_active, set_sound_1_active],
    /// Is true when sound channel 2 is active, and false otherwise.
    [1: sound_2_active, set_sound_2_active],
    /// Is true when sound channel 3 is active, and false otherwise.
    [2: sound_3_active, set_sound_3_active],
    /// Is true when sound channel 4 is active, and false otherwise.
    [3: sound_4_active, set_sound_4_active],
    /// Set true to enable audio output.
    /// Set false to disable all audio output.
    [7: sound_enabled, set_sound_enabled],
  }
}

const_enum! {
  /// Use to control the sampling rate and bit width for the digital-analog conversion. (DAC)
  /// Lower bit widths result in higher sample rates. This will have tradeoffs on the audio quality.
  SoundBiasSamplingSetting(u16) {
    /// Bit width of 9 with a sampling rate of 32.768kHz.
    /// 
    /// It is the default sampling rate.
    /// This is recommended if you wish to focus on DMA audio channels A and B.
    _9bit(0 << 14),
    /// Bit width of 8 with a sampling rate of 65.536kHz.
    _8bit(1 << 14),
    /// Bit width of 7 with a sampling rate of 131.072kHz.
    _7bit(2 << 14),
    /// Bit width of 6 with a sampling rate of 262.144kHz.
    /// 
    /// This is recommended if you wish to focus on PSG audio channels 1 through 4.
    _6bit(3 << 14),
  }
}

bitstruct_newtype! {
  /// Sound bias settings.
  SoundBiasSetting(u16) {
    /// Use to set the sound bias to be signed or unsigned.
    [1-9: bias_level, set_bias_level],
    /// Used to set the sampling rate.
    [14-15 => SoundBiasSamplingSetting: sampling_cycle, set_sampling_cycle],
  }
}
